---
title: "Module 5: Integrating Biological Knowledge"
author: "Diana Murray"
date: "July 30, 2020"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

data_dir <- "/home/rstudio/shared/data"
scripts_dir <- "/home/rstudio/shared/R"
source(file.path(scripts_dir, "submission_helpers.R"))
```

# About this activity

## Enrichment analysis
We will use the R package **clusterProfiler** to perform enrichment analysis of GO annotations for sets of genes we think may be related to motility. We started this analysis with Andrew in **Module 1**. We know from experience that we most likely do not need to write our own code to perform our analyses. But how do we know where to find trustworthy code?

Another package we could use is **gprofiler2**.  You can learn how to use this package in a [**great Nature Protocols paper**](https://pubmed.ncbi.nlm.nih.gov/30664679/).

## Bioconductor for R packages like `clusterProfiler`
The clusterProfiler package is maintained through [**Bioconductor**](https://bioconductor.org/), an open-source/open-development platform for bioinformatics tools in R. A large community of professionals supports the development, maintenance, and use of Bioconductor. 


If you're interested, there are a number of ways to [install Bioconductor packages into your local RStudio environment](https://bioconductor.org/install/).

At the top of the [Bioconductor page for clusterProfiler](http://bioconductor.org/packages/release/bioc/html/clusterProfiler.html), there are some metrics that describe how widely used and trustworthy the package is — e.g., its download profile (rank = 40/1905, in top 2% of downloaded packages), the support activity (most posted questions received answers), and a multi-platform check report ("all"). clusterProfiler is also supported by a [publication](https://www.ncbi.nlm.nih.gov/pubmed/22455463). It is also [available on github](https://guangchuangyu.github.io/software/clusterProfiler/). Overall, clusterProfiler looks like a solid package.

Available are a manual and **Vignettes**, which include examples of implementing clusterProfiler. The requirement of Vignettes is an outstanding feature of Bioconductor packages.  We will use only a few of the functions included in clusterProfiler. If you want to learn more about the package, you can work through [the clusterProfiler Vignettes](https://bioconductor.org/packages/devel/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html). 


## Bioconductor packages for this activity
1) [clusterProfiler](https://www.bioconductor.org/packages//2.10/bioc/html/clusterProfiler.html) for enrichment analysis
2) [org.Hs.eg.db](https://bioconductor.org/packages/release/data/annotation/html/org.Hs.eg.db.html) for help with gene annotation information https://bioconductor.org/packages/release/data/annotation/html/org.Hs.eg.db.html
3) [DOSE for Disease Ontology Semantics and Enrichment Analysis](https://bioconductor.org/packages/release/bioc/html/DOSE.html)


## Loading the packages for this activity
When we install packages on our local machines, we have to call them with the **`library()`** function.

```{r, message=FALSE, warning=FALSE}
library(clusterProfiler)   
library(org.Hs.eg.db)      
library(DOSE)
```


## Loading & formatting data
We revist the work we did in **Module 1** for loading and manipulating the PS-ON cell line expression and motility data.

Run the following chunk to load the data and to match (`merge`) with gene information.

```{r}
load(file.path(data_dir, "pson_expr_tpm_df.RData"))
load(file.path(data_dir, "pson_expr_gene_info.RData"))
load(file.path(data_dir, "pson_motility_tidy_df.RData"))

pson_expr_tpm_df2 <- merge(           # We are adding gene information
  x = gene_df, y = pson_expr_tpm_df,
  by.x = "gene_id", by.y = "gene_id"
)

pson_expr_tpm_df2[1:5,1:10]           # We use `indexing` to inspect 
```

We saw in earlier modules that there are many ways to identify genes. For example, human KRAS has the Ensembl id: "ENSG00000133703"; the hugo gene ID: KRAS; the UniProt ID: P01116; and the Entez ID: 3845. 

We will use the Ensembl `gene_id` (column 1) in our enrichment analysis, and we'll keep the HUGO `symbol` (column 3) so we can easily identify genes with their common names.

The following chunk creates the expression matrix for 18K+ genes across the ~60 cell lines.

```{r}
gene_symbol<-pson_expr_tpm_df2$symbol  # We keep the gene symbols 

pson_tpm_mat <- as.matrix(pson_expr_tpm_df2[, -c(1:5)])

pson_tpm_mat_Ensembl <- pson_tpm_mat
rownames(pson_tpm_mat_Ensembl) <- pson_expr_tpm_df2$gene_id

pson_logtpm_mat_Ensembl <- log2(1 + pson_tpm_mat_Ensembl)

pson_logtpm_mat_Ensembl[1:5, 1:5]   # The expression matix has 
                                    # Ensembl identifiers as row names
                                    # and cell line codes as column names
```


## Hyaluronic acid

We are interested in cell motility, so we are considering aspects of cell measurements in addition to gene expression, like cell speed. Here is a cartoon depiction of a cell in its biological environment. Extracellular matrix proteins include collagen (light blue), hyaluronic acid (dark blue), and fibronectin (green). These proteins are used in vitro as substrates on which to measure cell properties. In this activity, we'll look at cell speed measurements on the **hyaluronic acid substrate**.

```{r}
library(imager)

substrate_img<-load.image(file.path(data_dir,"substrate.JPG"))

plot(substrate_img,axes=FALSE)
```


This code chunk loads the cell speed data and selects the two breast cancer cell lines. We did this with Andrew in **Module 1**. 

```{r}
cell_speeds_df <- subset(pson_motil_tidy_df, summary_metric == "speed_um_hr")

hyal_coll_df <- subset(
  cell_speeds_df,
  experimentalCondition == "HyaluronicAcid Collagen"
)

samples_w_expr <- match(hyal_coll_df$sample, colnames(pson_logtpm_mat_Ensembl))

hyal_coll_logtpm_mat_Ensembl <- pson_logtpm_mat_Ensembl[, samples_w_expr]

which(hyal_coll_df$diagnosis == "Breast Cancer")

hyal_coll_df$cellLine[which(hyal_coll_df$diagnosis == "Breast Cancer")]
```

Last time we considered T-47D as a model for less agressive breast cancer and MDA-MB-231 as a model for more agressive breast cancer.

---

## Associating genes with differences in motility

In this chunk, we create a data frame that contains the ranked difference in expression between the two breast cancer cell lines, **T-47D** and **MDA-MB-231**.  Very different average speeds are observed on the hyaluronic acid collagen substrate: 16.5 u/hr for T-47D and 36.2 u/hr for MDA-MB-231.

```{r}
breast_logtpm_df <- data.frame(
  rownames(hyal_coll_logtpm_mat_Ensembl), 
  gene_symbol,
  hyal_coll_logtpm_mat_Ensembl[, c(7, 9)]
)

names(breast_logtpm_df) <- c("Ensembl", "hugo", "slower", "faster")

breast_logtpm_df$delta <- breast_logtpm_df[, "faster"] -
  breast_logtpm_df[, "slower"]
breast_logtpm_df <- breast_logtpm_df[order(breast_logtpm_df$delta, decreasing = TRUE), ]

rownames(breast_logtpm_df) <- NULL

head(breast_logtpm_df, 10)
```

The genes at the top of this list show much greater expression in the *faster* cell line (MDA-MB-231); if we had ordered the list by `decreasing = FALSE`, then we would have negative delta values at the top and be looking at genes with greater expression in the *slower* cell line (T-47D).

Since we are interested only in `delta` (expression in the faster cell line - expression in the slower cell line), we'll remove the columns for 'slower' and 'faster`.

```{r}
breast_logtpm_df2 <- breast_logtpm_df[, -c(3,4)]

```

In this chunk, we set up the gene list we need for performing the GO enrichment analysis.

`geneList_ensembl` is a ranked list of "delta" values (the difference in expression for each gene in the "fast" versus "slow" condition) with the Ensembl gene IDs as names. `clusterProfiler` likes to work with Ensembl IDs because they are stable, unique, and unambiguous.  `geneList_symbol` is the same ranked list but annotated with HUGO gene symbols for our reference.

```{r, warning=FALSE}
geneList_ensembl <- breast_logtpm_df2[, 3]
names(geneList_ensembl) <- breast_logtpm_df2[, 1]

geneList_symbol <- breast_logtpm_df2[, 3]
names(geneList_symbol) <- breast_logtpm_df2[, 2]

head(geneList_symbol,20)
tail(geneList_symbol,20)
```

## Vimentin and keratin in motility

With Andrew in **Module 1**, we inspected the genes at the top and bottom of this ranked list. Andrew noted that some of the genes most differentially expressed were lotto winners in terms of potential association with motility!

For example VIM, at the very top of the list codes for the protein vimentin, and KRT23, near the bottom codes for the protein keratin. 

This image comes from the paper, ["Vimentin induces changes in cell shape, motility, and adhesion during the epithelial to mesenchymal transition"](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2874471). 

Cells that express vimentin intermediate filaments (VIF) but not keratin intermediate filaments (KIF) are elongated in shape and more motile (panel A), whereas cells with KIF and not VIF are round and undergo fewer changes in morphology and position (panel B).

```{r}
VIF_KIF_img<-load.image(file.path(data_dir,"VIF_KIF.JPG"))

plot(VIF_KIF_img,axes=FALSE)
```

## Choosing our genes for enrichment analysis

To focus on the genes with the strongest apparent relationship to motility, we'll select only those at the top or bottom of the list. Choosing a cutoff in these situations can often be a bit arbitrary... We can use the `hist()` function to check the distribution of `delta` values and try to pick a threshold that includes a reasonable fraction of the "extreme" values.

```{r}
hist(geneList_ensembl, xlab = "Differential gene expression, delta")
abline(v = c(-4, 4), lty = 2)
```

Again, somewhat arbitrary, but we'll go ahead and use 4 as our cutoff for `delta` in both directions.

We create two sets of genes: 1) Those with "delta" less than or equal to -4 (genes with higher expression in the slow cell line (T-47D)), and 2) those with "delta" greater than or equal to +4 (genes with higher expression in the fast cell line (MDA-MB-231)).


```{r}
gene_ensembl_neg <- names(geneList_ensembl[(geneList_ensembl <= -4)])
gene_ensembl_pos <- names(geneList_ensembl[(geneList_ensembl >= 4)])

gene_symbol_neg <- names(geneList_symbol[(geneList_symbol <= -4)])
gene_symbol_pos <- names(geneList_symbol[(geneList_symbol >= 4)])

length(gene_ensembl_pos)
length(gene_ensembl_neg)


```


## Gene Ontology (GO) enrichment

The **clusterProfiler** package provides functions for performing a wide range of enrichment analyses.  We will focus on **`enrichGO`**, which annotates the genes in our list with GO terms and then looks for GO annotations that are significantly over- or under-represented.

Look at the arguments to the function. Note that the `pAdjustMethod` is set to `"BH"`. The Benjamini-Hochberg (BH) procedure decreases the false discovery rate in analysis. Adjusting the rate helps to control for the fact that sometimes small p-values (less than 5%) happen by chance, which could lead us to incorrectly rejecting the true null hypotheses. In other words, the BH Procedure helps us avoid Type I errors (false positives).

What will we use as our reference gene set or "universe"?  Why this list and not another?

Check out the documentation for the `enrichGO()` function to learn a bit more about how it works.

```{r}
?enrichGO
```

We'll first look for enriched **GO biological process terms** with the argument `ont = "BP"`. `ont` stands for ontology. 
Running the function will take a few moments.

We'll look at the top entries of our results.  Scroll horizontally through the columns and connect the output with the information we obtained Tuesday with the [online GO Panther enrichment tool](http://geneontology.org/). 

```{r}
ego_pson_pos <- enrichGO(
  gene = gene_ensembl_pos,
  universe = names(geneList_ensembl),
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.01,
  qvalueCutoff = 0.05,
  readable = TRUE
)

head(ego_pson_pos,12)
```

Are these annotations consistent with our "hypothesis" that genes with the greatest differential expression between the "fast" and "slow" breast cancer cell lines may be related to motility?

We can use the visualization tools **clusterProfile** provides to inspect our results.  Run the following chunk.  Do you prefer the output table above or the plot?

```{r}
help(dotplot)
```



```{r}
dotplot(ego_pson_pos,font.size=8,showCategory=12)
```


Let's look at the enrichment of annotations for genes at the bottom of the rank list — i.e. those genes that are under-expressed in "fast" versus "slow" breast cancer cell lines.

```{r, warning=FALSE}
ego_pson_neg <- enrichGO(
  gene = gene_ensembl_neg,
  universe = names(geneList_ensembl),
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  ont = "CC",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.01,
  qvalueCutoff = 0.05,
  readable = TRUE
)

head(ego_pson_neg)
```

So the genes at the bottom of our list- the genes overexpressed in the slower moving cells- clearly like to participate in tissue building.


```{r}
dotplot(ego_pson_neg,font.size=10)

```

## Practice

Recall that GO has three main aspects:

1. biological process (BP),
2. molecular function (MF),
3. cellular component (CC). 

We already looked at biological process (BP) annotations in the previous two examples.  Use the `enrichGO()` function, provided again in the next chunk, to examine the enrichment of "MF" and "CC" annotations.  

```{r, warning=FALSE}
ego_pson_pos <- enrichGO(
  gene = gene_ensembl_pos,
  universe = names(geneList_ensembl),
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",

  # To change the GO aspect, change the ont argument.  
  # It can be "BP", "MF", or "CC"

  ont = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff = 0.01,
  qvalueCutoff = 0.05,
  readable = TRUE
)

head(ego_pson_pos)
```

Use barplot or dotplot to visualize the enrichments.

```{r}
# visualize your results with dotplot() function

```

---

## Module 6 mini-DREAM Challenge

**QUESTION:** How does enrichment analysis look when we use the ranked absolute values of delta? Consider BP, MF, or CC.

In this activity, you will provide answers in six R objects:
* my_gene_count, line 385
* my_go_subontology, line 393
* my_top_go_id, line 415
* my_go_description, line 419
* my_fav_go_term, line 436
* my_rationale, lin3 439

First, let's set up the data to use as input for the `enrichGO` function.

```{r}
breast_logtpm_df3 <- breast_logtpm_df2   #  We will rename and use the data frame we
                                         #  created in the code chunks at lines 134 and 156

head(breast_logtpm_df3)
tail(breast_logtpm_df3)

```

So we have positive and negative values for delta.

```{r}
# Replace `aaa` with a function that will return the absolute values of delta.
# HINT: 'a' is the first letter of the function name...
breast_logtpm_df3[, 3] <- aaa(breast_logtpm_df3[, 3])

# Replace ?? with T or F.  How should the absolute values of delta be ranked? 
breast_logtpm_df3 <- breast_logtpm_df3[order(breast_logtpm_df3$delta, decreasing = ??), ]
head(breast_logtpm_df3)

geneList_abs <- breast_logtpm_df3[, 3]
names(geneList_abs) <- breast_logtpm_df3[, 1]

# Replace `nnnnn` with the function that will provide 
# the gene list information you need.
# HINT: 'n' is the first letter of the function name...
gene_pson_abs <- nnnnn(geneList_abs[(geneList_abs >= 4)])
```


Check the length of the resulting gene list, `gene_pson_abs` either using a command you've seen previously or by looking in the environment panel.

```{r}
# Uncomment the following line when you choose your function
# ffffff(gene_pson_abs)

# Replace NNN with the number of genes in the list
my_gene_count <- NNN
```

Now, pick a GO aspect — or "subontology" — and perform the enrichment analysis. Inspect the results and answer a few questions below.

```{r}
# set the GO aspect you want to use with `my_subontology`:
# replace NN with "BP", "MF", or "CC"
my_go_subontology <- "NN"

# Use one of the enrichGO implementations above to perform the analysis
ego_pson_abs <- enrichGO(
  gene = gene_pson_abs,
  universe = names(geneList_abs),
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  ont = my_go_subontology,
  pAdjustMethod = "BH",
  pvalueCutoff = 0.01,
  qvalueCutoff = 0.05,
  readable = TRUE
)

head(ego_pson_abs)
```

What did you find to be the most significantly enriched GO term in your list of genes, based on adjusted p-value?

```{r}
# fill in the GO term ID (e.g., "GO:0012345")
my_top_go_id <- " "

# fill in the description of the GO term 
# (you can copy/paste this from the table)
my_go_description <- " "
```


Use the visualization tool from above to interpret your results.

```{r}
# replace fff in the function name to create your plot as we did in line 265
fffplot(ego_pson_abs)
```

After looking at the plot, do you think that the top GO term from the table above is the most interesting? Which terms, if any, might be more informative of the biological mechanisms that drive motility differences between the two cell lines? Why?

```{r}
# fill in the name of your "favorite" GO term from the plot (use the values
# on the y-axis) — this could be the same or different from the 'go_description'
# you reported above
my_fav_go_term <- " "

# fill in your reason for choosing this GO term
my_rationale <- " "
```


## Submitting the prediction

You're now ready to submit the prediction. Just run the chunk below, a file with your prediction will be uploaded to Synapse and submitted to the challenge. You'll be able to see the results of your prediction on the mini-DREAM scoreboards, with the submission ID that gets printed below.

```{r}
synLoginSecure()  # You might be prompted for your username and password
submission <- submit_module_answers(module = 5)
```

Congrats — you’ve reached the end of **Module 6**! You can now return to the **mini-DREAM Challenge** site on Synapse.

---

# Bonus — Thought questions

How many genes are in the sets we analyzed?  What would be the consequences of including more or fewer genes in our sets?  What are the potential perils of having gene sets that are "too small" or "too large"?  Would you expect to obtain many statistical enrichments for a small set?  What might result when the set is too large?

