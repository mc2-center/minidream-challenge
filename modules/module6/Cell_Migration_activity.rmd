---
title: "Motor-clutch model and Cell Migration"
author: "Jay Hou and Brian Castle"
date: "7/14/2020"
output:
  pdf_document: default
  html_document: default
  html_notebook: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
data_dir <- "/home/rstudio/shared/data"
img_dir <- "/home/rstudio/shared/data/img"
scripts_dir <- "/home/rstudio/shared/R"
source(file.path(scripts_dir, "submission_helpers.R"))
```

### The goal of activity

The goal of this activity is to computationally model a cellular behavior staring from physical and chemical principles. In this activity, we'll simulate a **motor-clutch system** for cell traction dynamics as described by Chan and Odde, 2009. 

### Cell migration and metastasis
Cancer progression involves the dysregulation of cell division and cell migration. If malignant cells were capable only of proliferating and not migrating, then the resulting tumor would remain a local disease. Malignant tumors are so deadly because hyper-proliferative cells migrate away from the tumor mass and invade the surrounding tissue, often metastasizing to distant organs. 
Thus, *cell migration becomes a key driver of progression*. 

*Lamellipodia* are cytoskeletal protein actin projections on the leading edge of the cell. *Filopodia* are slender cytoplasmic projections that extend beyond the leading edge of lamellipodia in migrating cells. They contain actin filaments cross-linked into bundles by actin-binding proteins. Filopodia form focal adhesions with the substratum (or substrate). 

*Forces involved in migration are modeled by springs*
Protrusion of membrane lamellipodia and filopodia at the leading edge of the cell requires force generated by actin polymerization. Once the membrane protrusion adheres to the substrate, movement of the cell body forward occurs through 1) myosin interactions with actin filaments, 2) actin filament contraction, and 3) reversible binding of cell adhesion proteins to the substrate. The forces for these interactions can be modeled by springs. Forward movement requires a net force in the forward direction (Lauffenburger 1996) . 

*A cellular motor-clutch system*
Cells can transmit forces to their surroundings through a **cellular motor-clutch system**, where molecular clutches (i.e. cell adhesion proteins) link the F-actin cytoskeleton to the substrate and mechanically resist myosin motor-driven F-actin retrograde (or backward) flow. The system is analogous to a motor-clutch system in a vehicle, where the clutch acts as a link between the engine and the drive train. 

```{r}
knitr::include_graphics(file.path(img_dir,"fig_migration.jpg"))
```


### Model description

**Figure 2** is a schematic of the **mechano-chemical motor-clutch model** (Chan and Odde, 2008). Myosin motors pull an F-actin bundle to the left with force F(M) at velocity v(filament). Cell protrusion at the leading edge pulls the cell to the right through the action of motor clutches (adhesion proteins), which are modeled as springs. The clutches reversibly engage the F-actin bundle with rates k(on) and k(off) to resist the movement to the left. In the process, clutch 1 is stretched the distance x(clutch) and the interaction fails with a force-dependent off rate k(off)*. The sum of the forces induces a strain on the substrate and changes its position, x(sub). The mechanical stiffness of the clutches K(c) and the substrate K(sub) determine the overall resistance to migration.

```{r}
knitr::include_graphics(file.path(img_dir,"fig_motor_clutch.jpg"))
```


*Parameter definitions*
To begin, we need to first define the constant parameters for the simulations. Refer to Tuesday’s presentation and to Table S1 from Chan and Odde (2008) for detailed descriptions. 

1. Total number of myosin motors, motorNum = 75
2. Stall force for a single motor, motorForce = -2 pN
3. Unloaded myosin motor velocity, motorVel = -120 nm/s
4. Total number of clutches, clutchNum= 75
5. Pseudo-first order clutch association rate, clutchOn = 1 s^-1
6. First-order clutch unloaded dissociation rate, clutchOff = 0.1 s^-1
7. Clutch spring constant, clutchKs = 5 pN/nm
8. Compliant substrate spring constant, subKs = 1 pN/nm
9. Characteristic bond rupture force, bondForce = -2 pN

Negative values mean that the respective forces or movements are applied in the negative x-direction (to the left in **Figure 2**).


### Exercise 1: clutch dynamics

Clutch binding is a chemical reaction and can be simulated.

For a single clutch, the reaction scheme is
```{r}
knitr::include_graphics(file.path(img_dir,"eq_reaction.png"))
```
where A is the unbound clutch, B is bound clutch.

Last time, we saw that the probability of clutch binding is given by the exponential function, and B concentration changing with time.
```{r}
knitr::include_graphics(file.path(img_dir,"eq_reaction_P.png"))
knitr::include_graphics(file.path(img_dir,"eq_reaction_B.png"))
```

*Simulate an array of clutches*
With multiple clutches, we use 2D arrays to keep track of the individual states, so now `clutchState`, `csArray` and `timeArray` are matrices. 

For each time step:
1. Check the current state of the clutch, bound or unbound.
2. Determine the probability the clutch changes state. 
3. Execute based on random number generation.
4. Record the elapsed time.
5. Record the clutch state at the current time point.

```{r}
# Assign parameters
clutchNum <- 75     
kon <- 1       # s^-1
koff <- 0.1    # s^-1

timeStep <- 0.01      # seconds
numSteps <- 1000;

# main code

clutchState <- matrix(0,clutchNum,1)     # 0 for unbound, 1 for bound
csArray <- matrix(0,numSteps,1)          # clutch bound array
timeArray <- matrix(0,numSteps,1)        # elapsed time

for (i in 2:numSteps) {                  # Define simulation space
  for (j in 1:clutchNum) {               # Loop through each clutch
    if (clutchState[j] == 0) {             # If clutch is unbound
      pBind = 1 -exp(-kon*timeStep)   # Equation 2
      temp <- runif(1)                     # Random number generation
      if (temp <= pBind) {                 # Does event occur?
        clutchState[j] <- 1 }              # If so, clutch is bound
    }
    if (clutchState[j] == 1) {               # If clutch is bound
      pUnbind <- 1 -exp(-koff*timeStep) # Equation 2
      temp <- runif(1)                       # Random number generation
      if (temp <= pUnbind) {                 # Does event occur?
        clutchState[j] <- 0 }                # If so, clutch is unbound
    }
  }
  timeArray[i] <- timeArray[i-1]+timeStep  # Record current time
  csArray[i]<-sum(clutchState)             # record number of bound clutches
}

plot(timeArray,csArray,type="l", ylim=c(0,max(csArray)),xlab="Time (sec)",ylab="Number of bound clutches",col="blue")

clutchbCalc = (kon*clutchNum/(kon+koff))-(kon*clutchNum/(kon+koff))*exp(-1*(kon+koff)*timeArray)
lines(timeArray, clutchbCalc, col="red",lty=1)
```

*Code check and Challenge Questions*
We should see stochasic simulation fits nicely with analytical solution.

1. What is the equilibrium bound clutch number (nc_bound_final)?
2. What is the half time of this reaction (nc_bound(time_half) = 0.5*nc_bound_final)?

*bonus*
1. How will kon, koff, clutchNum affect simulation results?
2. Why stochastic simulation results fluctuate with time? What are the benefits from this behavior?

```{r}
# Challenge Question
#nc_bound_final <-
#time_half<-
```

### Exercise 2: F-actin flow stretching clutches

Now that we have code for simulating the dynamics of multiple clutches, we can bind clutches to F-actin and stretch the clutches due to F-actin flow.

```{r}
knitr::include_graphics(file.path(img_dir,"fig_motor_clutch.jpg"))
```

*Bell model for bond kinetics*
```{r}
knitr::include_graphics(file.path(img_dir,"eq_reaction_Bell.png"))
```

*protein force using Hooke's law*
Each clutch, as well as the substrate, is treated as a Hookean spring so that F = -K*x.

```{r}
knitr::include_graphics(file.path(img_dir,"eq_reaction_bondF.png"))
```

*simulation*
For each time step, 

1. stretch bond clutches using constant F-actin flow
2. calculate clutch forces
3. calculate clutch bond and unbound probability
4. bond and unbond the clutches

Now simulate!
```{r}
# parameters
clutchNum <- 75     
kon <- 1       # s^-1
koff <- 0.1    # s^-1
clutchK <- 5       # pN/nm
bondForce <- 2      # pN
actinFlow <- 120

timeStep = 0.01      # seconds
numSteps = 100;

# Initialize
clutchState <- matrix(0,clutchNum,1)
clutchdx <- matrix(0,clutchNum,1)
clutchF <- matrix(0,clutchNum,1)
moduleF <- 0
timeArray <- matrix(0,numSteps,1)
csArray <- matrix(0,numSteps,1)
FArray <- matrix(0,numSteps,1)

# The first part of this chunk is the same as before
for (i in 2:numSteps) {

    for (j in 1:clutchNum) {
    
    if (clutchState[j] == 0) {
      pBind = 1 -exp(-kon*timeStep)
      temp <- runif(1)
      if (temp <= pBind) {
        clutchState[j] <- 1 }
    }
    if (clutchState[j] == 1) {
      pUnbind <- 1 -exp(-koff*exp(clutchF[j]/bondForce)*timeStep)
      temp <- runif(1)
      if (temp <= pUnbind) {
        clutchState[j] <- 0 
        clutchdx[j] <- 0;
      }
    }
    if (clutchState[j] == 1) {   # if clutch is bound
      clutchdx[j] <- clutchdx[j] + actinFlow*timeStep   # clutch stretched by flow
    }
  }
  
  engNum = sum(clutchState)

  moduleF = 0
  for (j in 1:clutchNum) {
      clutchF[j] = clutchK*abs(clutchdx[j])
      moduleF = moduleF + clutchF[j]
  }
  
  timeArray[i] = timeArray[i-1] + timeStep
  csArray[i]=engNum     
  FArray[i]=moduleF
}

plot(timeArray,csArray,type="l",xlim=c(0,max(timeArray)), ylim=c(0,max(csArray)+2),xlab="Time (sec)",ylab="Number of bound clutches",col="blue")

plot(timeArray,FArray,type="l",xlim=c(0,max(timeArray)), ylim=c(0,max(FArray)+2),xlab="Time (sec)",ylab="module force",col="blue")

```

*Code check and Challenge Questions*
We should see bound clutch number fluctuates with time, so does force.

1. What is the approximate frequency for clutches to unbound (unbound_freq)?
2. What is the mean module force (mforce_mean)?

*bonus*
1. How will kon, koff, clutchNum, clutchK, actinFlow affect simulation results?

2. Is module force = clutch bound number * clutchK? If not, why?

```{r}
# Challenge Question
#unbound_freq <-
#mforce_mean<-
```


### Exercise 3: substrate is deformable

Now we can apply total clutch forces to a deformable substrate, and the deformation of substrate can affect system dynamics.

*motor-clutch model*
```{r}
knitr::include_graphics(file.path(img_dir,"fig_motor_clutch.jpg"))
```

*clutch binding position*
```{r}
knitr::include_graphics(file.path(img_dir,"eq_clutchx.png"))
```

*substrate position*
substrate position is determined by clutch position, clutch stiffness, and substrate stiffness

```{r}
knitr::include_graphics(file.path(img_dir,"eq_xsub.png"))
```

*clutch final stretch*
clutch stretch is updated with substrate position

```{r}
knitr::include_graphics(file.path(img_dir,"eq_clutch_final_stretch.png"))
```

*simulation*
For each time step, 

1. stretch bond clutches using constant F-actin flow
2. calculate clutch forces
3. calculate clutch bond and unbound probability
4. bond and unbond the clutches

Now simulate!
```{r}
# parameters
clutchNum <- 75     
kon <- 1       # s^-1
koff <- 0.1    # s^-1
clutchK <- 5       # pN/nm
bondForce <- 2      # pN
subK <- 0.1          # pN/m
actinFlow <- 120

timeStep = 0.01      # seconds
numSteps = 10000;

# Initialize
clutchState <- matrix(0,clutchNum,1)
clutchdx <- matrix(0,clutchNum,1)
clutchx <- matrix(0,clutchNum,1)
clutchF <- matrix(0,clutchNum,1)
moduleF <- 0
subx <- 0
csArray <- matrix(0,numSteps,1)
timeArray <- matrix(0,numSteps,1)
FArray <- matrix(0,numSteps,1)
FlowArray <- matrix(0,numSteps,1)
SubxArray <- matrix(0,numSteps,1)

# The first part of this chunk is the same as before
for (i in 2:numSteps) {

    for (j in 1:clutchNum) {
    
    if (clutchState[j] == 0) {
      pBind = 1 -exp(-kon*timeStep)
      temp <- runif(1)
      if (temp <= pBind) {
        clutchState[j] <- 1 }
    }
    if (clutchState[j] == 1) {
      pUnbind <- 1 -exp(-koff*exp(clutchF[j]/bondForce)*timeStep)
      temp <- runif(1)
      if (temp <= pUnbind) {
        clutchState[j] <- 0 
        clutchdx[j] <- 0;
      }
    }
    if (clutchState[j] == 1) {   # if clutch is bound
      clutchdx[j] <- clutchdx[j] + actinFlow*timeStep   # clutch stretched by flow
    }
    
    clutchx[j] = clutchdx[j] + subx
  }
  
  subx = 0
  for (j in 1:clutchNum) {
    if (clutchState[j] == 1) {
      subx = subx + clutchx[j]
    }
  }
  engNum = sum(clutchState)

  subx = subx*clutchK/(subK+clutchK*engNum)
  
  moduleF = 0
  for (j in 1:clutchNum) {
    if (clutchState[j] == 1) {
      clutchdx[j] = clutchx[j] - subx
    }
    if (clutchState[j] == 0) {
      clutchdx[j] = 0
    }
      clutchF[j] = clutchK*abs(clutchdx[j])
      moduleF = moduleF + clutchF[j]
  }
  
  timeArray[i] = timeArray[i-1] + timeStep
  csArray[i]=engNum     
  FArray[i]=moduleF
  SubxArray[i]=subx
}

plot(timeArray,csArray,type="l",xlim=c(0,max(timeArray)), ylim=c(0,max(csArray)+2),xlab="Time (sec)",ylab="Number of bound clutches",col="blue")

plot(timeArray,FArray,type="l",xlim=c(0,max(timeArray)), ylim=c(0,max(FArray)+2),xlab="Time (sec)",ylab="module force",col="blue")

plot(timeArray,SubxArray,type="l",xlim=c(0,max(timeArray)), ylim=c(0,max(SubxArray)+2),xlab="Time (sec)",ylab="substrate position",col="blue")

```

*Code check and Challenge Questions*
We should see bound clutch number accumulates and unbound with time, so do module force and substrate deformation.

1. What is the approximate frequency for clutches to unbound (unbound_freq_deform)?
2. What is the mean module force (mforce_mean_deform)?
3. Is substrate deformation = module force * subK? (Equation_SubDeform_MForce = yes or no)

*bonus*
1. How will subK affect simulation results?

2. When subK becomes very large, will the results become similar to Exercise 2?

```{r}
# Challenge Question
#unbound_freq_deform <-
#mforce_mean_deform<-
#Equation_SubDeform_MForce<-
```


### motor-clutch model can mimic experimental results

* Clutches bind and unbind F-actin stochastically based on clutch forces
* Total clutch forces constitute module force to apply to compliant substrate
* F-actin flow is a function of force balance between myosin motor forces and module force

*motor-clutch model*
```{r}
knitr::include_graphics(file.path(img_dir,"fig_motor_clutch.jpg"))
```

*simulations and experiments*
* cell is pulling the substrate stochastically
* simulation results for F-actin flow and traction force
* consistent with experiemntal results results for neurons contracting on polyacrylamide gels
```{r}
knitr::include_graphics(file.path(img_dir,"fig_exp_deformation.png"))
knitr::include_graphics(file.path(img_dir,"fig_motor_clutch_result.png"))
```

### cell migration simulator

* Multiple motor-clutch systems to mimic cell protrusions
* Modules elongate and shorten by polymerization and F-actin flow
* Cell position is determined by force balance between modules

*cell migration simulator*

```{r}
knitr::include_graphics(file.path(img_dir,"fig_CMS.png"))
```

*simulations and experiments*
* simulation results for cell migration motility (random motility coefficent), traction force, F-actin flow
* consistent with experiemntal results results for U251 glioma cells on polyacrylamide gels
```{r}
knitr::include_graphics(file.path(img_dir,"fig_CMS_result.png"))
```

### Submitting the prediction

You're now ready to submit the prediction. Just run the chunk below, a file with your prediction will be uploaded to Synapse and submitted to the challenge. You'll be able to see the results of your prediction on the mini-DREAM scoreboards, with the submission ID that gets printed below.

```{r}
synLoginSecure()  # You might be prompted for your username and password
submission <- submit_module_answers(module = 6)
```


### the end

Congrats — you’ve reached the end of **Module 6*! 
One last code chunk:

```{r}
knitr::include_graphics(file.path(img_dir,"fig_Last.jpg"))
```




